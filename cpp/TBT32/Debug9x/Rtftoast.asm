; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\Rtftoast.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NLJIHOMM@?5?9?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03BFOLIMEF@?$FN?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KMKIHNKG@?5?91234567890?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BKJPHGNJ@pc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KEPONAMI@ansi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BLFNBMOO@qc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MKJPKHKH@qj?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JMMFAACB@ql?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EIPGLLEK@fs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LMHBEHJN@ulnone?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03OBJIDKBM@par?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MLFFEHBF@?$HO?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0Strbuff@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Strbuff@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@Strbuff@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@Strbuff@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?puts@Strbuff@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?putback@Strbuff@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GStrbuff@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_state@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hval@@YAHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read_hex2@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read_int@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read_name@@YAHAAVStrbuff@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_state@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pard@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_code_word@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_caps@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_inv@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?output_bold@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_code@@YAHPAUCODE_WORD@@AAVStrbuff@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__LINE__Var@?1??AtlThrow@ATL@@YGXJ@Z@4JA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FC@IPKABFFL@c?3?2program?5files?2microsoft?5visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Strbuff@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_03NLJIHOMM@?5?9?5?$AA@			; `string'
PUBLIC	??_C@_02BAABKJLB@?9?9?$AA@			; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_01DNKMNLPK@?$HM?$AA@			; `string'
PUBLIC	??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
_DATA	SEGMENT
_cwd_count DD	03bH
_state_sp DD	0ffffffffH
_curr_state DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	018H
_DATA	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLJIHOMM@?5?9?5?$AA@
CONST	SEGMENT
??_C@_03NLJIHOMM@?5?9?5?$AA@ DB ' - ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9?$AA@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9?$AA@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM?$AA@ DB '|', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@ DB '     ', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+4
_cwd_array DB	'par', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'b', 00H
	ORG $+28
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_bold@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'i', 00H
	ORG $+28
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ul', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ulw', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'uld', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'uldb', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'plain', 00H
	ORG $+24
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'plain', 00H
	ORG $+24
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'lquote', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_01GEODFPGF@?8?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'rquote', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_01GEODFPGF@?8?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ldblquote', 00H
	ORG $+20
	ORG $+2
	DD	FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'rdblquote', 00H
	ORG $+20
	ORG $+2
	DD	FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'endash', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_03NLJIHOMM@?5?9?5?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'emdash', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_02BAABKJLB@?9?9?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'bullet', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_01NBENCBCI@?$CK?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'footnote', 00H
	ORG $+21
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'footer', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'header', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'pic', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fonttbl', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'stylesheet', 00H
	ORG $+19
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'info', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'colortbl', 00H
	ORG $+21
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'atnid', 00H
	ORG $+24
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'annotation', 00H
	ORG $+19
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'field', 00H
	ORG $+24
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fldinst', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'footerl', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'headerl', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'pard', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?pard@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'footerr', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'headerr', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'footerf', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'headerf', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'txe', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ixe', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'bxe', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'rxe', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'bkmkstart', 00H
	ORG $+20
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'bkmkend', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'nextfile', 00H
	ORG $+21
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'template', 00H
	ORG $+21
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ansi', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'pc', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'tab', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_01DNKMNLPK@?$HM?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'caps', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?set_caps@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'v', 00H
	ORG $+28
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?set_inv@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fs', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'qc', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'ql', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'qj', 00H
	ORG $+27
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'froman', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fswiss', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fnil', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fsymbol', 00H
	ORG $+22
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'fdecor', 00H
	ORG $+23
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'red', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'blue', 00H
	ORG $+25
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'green', 00H
	ORG $+24
	ORG $+2
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
	DB	'tab', 00H
	ORG $+26
	ORG $+2
	DD	FLAT:??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@
	DD	FLAT:?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_winc	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	027H
	DB	027H
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	020H
	DB	0adH
	DB	09bH
	DB	09cH
	DB	0afH
	DB	09dH
	DB	07cH
	DB	015H
	DB	022H
	DB	043H
	DB	0a6H
	DB	0aeH
	DB	0aaH
	DB	02dH
	DB	052H
	DB	0c4H
	DB	016H
	DB	0f1H
	DB	0fdH
	DB	02aH
	DB	027H
	DB	0e6H
	DB	014H
	DB	0f9H
	DB	02cH
	DB	027H
	DB	0a7H
	DB	0afH
	DB	0acH
	DB	0abH
	DB	03fH
	DB	0a8H
	DB	041H
	DB	041H
	DB	041H
	DB	041H
	DB	08eH
	DB	08fH
	DB	092H
	DB	080H
	DB	045H
	DB	045H
	DB	045H
	DB	090H
	DB	08dH
	DB	0a1H
	DB	08cH
	DB	08bH
	DB	044H
	DB	0a5H
	DB	04fH
	DB	04fH
	DB	04fH
	DB	04fH
	DB	099H
	DB	078H
	DB	09dH
	DB	055H
	DB	055H
	DB	055H
	DB	09aH
	DB	059H
	DB	09eH
	DB	0e1H
	DB	085H
	DB	0a0H
	DB	083H
	DB	061H
	DB	084H
	DB	086H
	DB	091H
	DB	087H
	DB	08aH
	DB	082H
	DB	088H
	DB	089H
	DB	08dH
	DB	0a1H
	DB	08cH
	DB	08bH
	DB	064H
	DB	0a4H
	DB	095H
	DB	0a2H
	DB	093H
	DB	06fH
	DB	094H
	DB	0f6H
	DB	09bH
	DB	097H
	DB	0a3H
	DB	096H
	DB	081H
	DB	079H
	DB	09eH
	DB	098H
_DATA	ENDS
PUBLIC	?hval@@YAHD@Z					; hval
EXTRN	_isupper:NEAR
EXTRN	_isdigit:NEAR
EXTRN	_isxdigit:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
;	COMDAT rtc$IMZ
; File c:\astrow32dev\tbt32\rtftoast.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCcsu /ZI
rtc$TMZ	ENDS
;	COMDAT ?hval@@YAHD@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?hval@@YAHD@Z PROC NEAR					; hval, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 110  :  if ( _istdigit(c) )

	movsx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $L93480

; 111  :     return( c - _T('0')  );

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $L93479
$L93480:

; 112  :  else if ( _istxdigit(c) && _istupper(c) )

	movsx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_isxdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $L93482
	movsx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_isupper
	add	esp, 4
	test	eax, eax
	je	SHORT $L93482

; 113  :     return( c - _T('A')+10 );   

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 55					; 00000037H
	jmp	SHORT $L93479
$L93482:

; 114  :  else
; 115  :     return( c - _T('a')+10 );   

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 87					; 00000057H
$L93479:

; 116  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?hval@@YAHD@Z ENDP					; hval
_TEXT	ENDS
PUBLIC	?read_hex2@@YAHAAVStrbuff@@@Z			; read_hex2
PUBLIC	?putback@Strbuff@@QAEXD@Z			; Strbuff::putback
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	?get@Strbuff@@QAEEXZ:NEAR			; Strbuff::get
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?read_hex2@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT
_buf$ = -32						; size = 10
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_stream$ = 8						; size = 4
?read_hex2@@YAHAAVStrbuff@@@Z PROC NEAR			; read_hex2, COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 121  :  int i;
; 122  :  TCHAR buf[10];
; 123  : 
; 124  :  buf[0] = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	mov	BYTE PTR _buf$[ebp], al

; 125  :  if ( !_istxdigit(buf[0]) ) {

	movsx	eax, BYTE PTR _buf$[ebp]
	push	eax
	call	_isxdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $L93489

; 126  :     stream.putback( buf[0] );

	mov	al, BYTE PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 127  :     return( 0 );

	xor	eax, eax
	jmp	SHORT $L93486
$L93489:

; 128  :     }
; 129  :  buf[1] = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	mov	BYTE PTR _buf$[ebp+1], al

; 130  :  if ( !_istxdigit(buf[1]) ) {

	movsx	eax, BYTE PTR _buf$[ebp+1]
	push	eax
	call	_isxdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $L93490

; 131  :     stream.putback( buf[1] );

	mov	al, BYTE PTR _buf$[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 132  :     buf[1] = _T('\0');

	mov	BYTE PTR _buf$[ebp+1], 0
$L93490:

; 133  :     }
; 134  :  buf[2] = _T('\0');

	mov	BYTE PTR _buf$[ebp+2], 0

; 135  :  return( (hval(buf[0])*16) + hval(buf[1]) );

	mov	al, BYTE PTR _buf$[ebp]
	push	eax
	call	?hval@@YAHD@Z				; hval
	add	esp, 4
	mov	esi, eax
	shl	esi, 4
	mov	cl, BYTE PTR _buf$[ebp+1]
	push	ecx
	call	?hval@@YAHD@Z				; hval
	add	esp, 4
	add	eax, esi
$L93486:

; 136  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93882
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93882:
	DD	1
	DD	$L93881
$L93881:
	DD	-32					; ffffffe0H
	DD	10					; 0000000aH
	DD	$L93878
$L93878:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?read_hex2@@YAHAAVStrbuff@@@Z ENDP			; read_hex2
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\strbuff.h
_TEXT	ENDS
;	COMDAT ?putback@Strbuff@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$ = 8							; size = 1
?putback@Strbuff@@QAEXD@Z PROC NEAR			; Strbuff::putback, COMDAT
; _this$ = ecx

; 30   :     void putback( TCHAR c ) { index--; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putback@Strbuff@@QAEXD@Z ENDP				; Strbuff::putback
_TEXT	ENDS
PUBLIC	?read_int@@YAHAAVStrbuff@@@Z			; read_int
PUBLIC	?eof@Strbuff@@QAEHXZ				; Strbuff::eof
EXTRN	_atoi:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\rtftoast.cpp
;	COMDAT ?read_int@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT
_buf$ = -36						; size = 15
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_stream$ = 8						; size = 4
?read_int@@YAHAAVStrbuff@@@Z PROC NEAR			; read_int, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 140  :  int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L93496:

; 141  :  TCHAR buf[15];
; 142  : 
; 143  :  do {
; 144  :     buf[i] = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], al

; 145  :     if ( !_istdigit(buf[i]) ) {

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buf$[ebp+eax]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $L93499

; 146  :        stream.putback( buf[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _buf$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 147  :        buf[i] = _T('\0');

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0

; 148  :        break;

	jmp	SHORT $L93498
$L93499:

; 149  :        }
; 150  :     i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 151  :     } while ( _istdigit(buf[i-1]) && !stream.eof() );

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buf$[ebp+eax-1]
	push	ecx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $L93498
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?eof@Strbuff@@QAEHXZ			; Strbuff::eof
	test	eax, eax
	je	SHORT $L93496
$L93498:

; 152  :  buf[i] = _T('\0');

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0

; 153  :  return( _tstoi(buf) );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_atoi
	add	esp, 4

; 154  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93893
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93893:
	DD	1
	DD	$L93892
$L93892:
	DD	-36					; ffffffdcH
	DD	15					; 0000000fH
	DD	$L93890
$L93890:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?read_int@@YAHAAVStrbuff@@@Z ENDP			; read_int
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\strbuff.h
_TEXT	ENDS
;	COMDAT ?eof@Strbuff@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?eof@Strbuff@@QAEHXZ PROC NEAR				; Strbuff::eof, COMDAT
; _this$ = ecx

; 23   : 	BOOL eof() {return(index<len?FALSE:TRUE);}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+160]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+156]
	setge	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eof@Strbuff@@QAEHXZ ENDP				; Strbuff::eof
_TEXT	ENDS
PUBLIC	?read_name@@YAHAAVStrbuff@@PAD@Z		; read_name
EXTRN	_isalpha:NEAR
EXTRN	_strcpy:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\rtftoast.cpp
;	COMDAT ?read_name@@YAHAAVStrbuff@@PAD@Z
_TEXT	SEGMENT
_buf$ = -56						; size = 35
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_stream$ = 8						; size = 4
_str$ = 12						; size = 4
?read_name@@YAHAAVStrbuff@@PAD@Z PROC NEAR		; read_name, COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 159  :  int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L93507:

; 160  :  TCHAR buf[35];
; 161  : 
; 162  :  do {
; 163  :     buf[i] = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], al

; 164  :     if ( !_istalpha(buf[i]) ) {

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buf$[ebp+eax]
	push	ecx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $L93510

; 165  :        stream.putback( buf[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _buf$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 166  :        buf[i] = _T('\0');

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0

; 167  :        break;

	jmp	SHORT $L93509
$L93510:

; 168  :        }
; 169  :     i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 170  :     } while ( _istalpha(buf[i-1]) && !stream.eof() );

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _buf$[ebp+eax-1]
	push	ecx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	je	SHORT $L93509
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?eof@Strbuff@@QAEHXZ			; Strbuff::eof
	test	eax, eax
	je	SHORT $L93507
$L93509:

; 171  :  buf[i] = _T('\0');

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 0

; 172  :  _tcscpy( str, buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 173  :  return( i );

	mov	eax, DWORD PTR _i$[ebp]

; 174  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93902
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93902:
	DD	1
	DD	$L93901
$L93901:
	DD	-56					; ffffffc8H
	DD	35					; 00000023H
	DD	$L93899
$L93899:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?read_name@@YAHAAVStrbuff@@PAD@Z ENDP			; read_name
_TEXT	ENDS
PUBLIC	??_C@_03BFOLIMEF@?$FN?$AN?6?$AA@		; `string'
PUBLIC	?puts@Strbuff@@QAEXPBD@Z			; Strbuff::puts
EXTRN	?put@Strbuff@@QAEXD@Z:NEAR			; Strbuff::put
;	COMDAT ??_C@_03BFOLIMEF@?$FN?$AN?6?$AA@
CONST	SEGMENT
??_C@_03BFOLIMEF@?$FN?$AN?6?$AA@ DB ']', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?pard@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?pard@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; pard, COMDAT

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 191  :     if ( curr_state.head )

	cmp	DWORD PTR _curr_state+20, 0
	je	SHORT $L93522

; 192  :        out.puts( _T("]\r\n")  );

	push	OFFSET FLAT:??_C@_03BFOLIMEF@?$FN?$AN?6?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	?puts@Strbuff@@QAEXPBD@Z		; Strbuff::puts

; 193  :     else if ( curr_state.bold )

	jmp	SHORT $L93524
$L93522:
	cmp	DWORD PTR _curr_state+12, 0
	je	SHORT $L93524

; 194  :        out.put( _T('}')  );

	push	125					; 0000007dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put
$L93524:

; 195  :     if ( curr_state.underscore )

	cmp	DWORD PTR _curr_state+16, 0
	je	SHORT $L93526

; 196  :        out.put( _T('>')  );

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put
$L93526:

; 197  :     return( 1 );

	mov	eax, 1

; 198  :  
; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pard@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP		; pard
_TEXT	ENDS
PUBLIC	??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\strbuff.h
;	COMDAT ?puts@Strbuff@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = 8							; size = 4
?puts@Strbuff@@QAEXPBD@Z PROC NEAR			; Strbuff::puts, COMDAT
; _this$ = ecx

; 28   : 	void puts( const _TCHAR *p ) { if ( len ) { str+=buf; len=0; } str+=p; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+156], 0
	je	SHORT $L92994
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0
$L92994:
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?puts@Strbuff@@QAEXPBD@Z ENDP				; Strbuff::puts
_TEXT	ENDS
PUBLIC	??_C@_02BKJPHGNJ@pc?$AA@			; `string'
PUBLIC	??_C@_04KEPONAMI@ansi?$AA@			; `string'
EXTRN	__stricmp:NEAR
_BSS	SEGMENT
_map_win DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_02BKJPHGNJ@pc?$AA@
; File c:\astrow32dev\tbt32\rtftoast.cpp
CONST	SEGMENT
??_C@_02BKJPHGNJ@pc?$AA@ DB 'pc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEPONAMI@ansi?$AA@
CONST	SEGMENT
??_C@_04KEPONAMI@ansi?$AA@ DB 'ansi', 00H		; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; set_win, COMDAT

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 264  :  if ( !_tcsicmp( cwp->name, _T("pc" ) ) )

	push	OFFSET FLAT:??_C@_02BKJPHGNJ@pc?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93558

; 265  :     map_win = 0;

	mov	DWORD PTR _map_win, 0

; 266  :  else if ( !_tcsicmp( cwp->name, _T("ansi" ) ) )

	jmp	SHORT $L93560
$L93558:
	push	OFFSET FLAT:??_C@_04KEPONAMI@ansi?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93560

; 267  :     map_win = 1;

	mov	DWORD PTR _map_win, 1
$L93560:

; 268  :  return( 0 );

	xor	eax, eax

; 269  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?set_win@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; set_win
_TEXT	ENDS
_BSS	SEGMENT
_brace_state DD	01H DUP (?)
; Function compile flags: /Odt /RTCcsu /ZI
_BSS	ENDS
;	COMDAT ?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
tv67 = -268						; size = 4
_cw$ = -68						; size = 36
_c$ = -24						; size = 4
_level$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR ; skip_dest, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 302  :  int level = brace_state, c;

	mov	eax, DWORD PTR _brace_state
	mov	DWORD PTR _level$[ebp], eax

; 303  :  CODE_WORD cw;
; 304  : 
; 305  :  curr_state.map_inv = 1;

	mov	DWORD PTR _curr_state+4, 1
$L93588:

; 306  :  do {
; 307  :     c = rtf_read( in, &cw );

	lea	eax, DWORD PTR _cw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z ; rtf_read
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 308  :     switch( c ) {

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv67[ebp], eax

; 309  : 	  case RCBRA :
; 310  : 	       break;
; 311  : 	  case ROBRA :
; 312  : 	  case RCODE :
; 313  : 	  default :
; 314  : 	     continue;
; 315  : 	  }
; 316  :     } while ( brace_state > level-1 );

	mov	eax, DWORD PTR _level$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _brace_state, eax
	jg	SHORT $L93588

; 317  :  pop_state( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?pop_state@@YAHAAVStrbuff@@@Z		; pop_state
	add	esp, 4

; 318  :  curr_state.map_inv = 0;

	mov	DWORD PTR _curr_state+4, 0

; 319  :  return( 1 );

	mov	eax, 1

; 320  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93915
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93915:
	DD	1
	DD	$L93914
$L93914:
	DD	-68					; ffffffbcH
	DD	36					; 00000024H
	DD	$L93912
$L93912:
	DB	99					; 00000063H
	DB	119					; 00000077H
	DB	0
?skip_dest@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; skip_dest
_TEXT	ENDS
_BSS	SEGMENT
_state_stack DB	02bcH DUP (?)
; Function compile flags: /Odt /RTCcsu /ZI
_BSS	ENDS
;	COMDAT ?pop_state@@YAHAAVStrbuff@@@Z
_TEXT	SEGMENT
_tos$ = -32						; size = 28
_out$ = 8						; size = 4
?pop_state@@YAHAAVStrbuff@@@Z PROC NEAR			; pop_state, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   :  STATE tos;
; 81   : 
; 82   :  if ( state_sp > 0 ) {

	cmp	DWORD PTR _state_sp, 0
	jle	$L93465

; 83   :     tos = state_stack[state_sp--];

	mov	esi, DWORD PTR _state_sp
	imul	esi, 28					; 0000001cH
	add	esi, OFFSET FLAT:_state_stack
	mov	ecx, 7
	lea	edi, DWORD PTR _tos$[ebp]
	rep movsd
	mov	eax, DWORD PTR _state_sp
	sub	eax, 1
	mov	DWORD PTR _state_sp, eax

; 84   :     if ( curr_state.map_inv ) {

	cmp	DWORD PTR _curr_state+4, 0
	je	SHORT $L93466

; 85   :        curr_state = tos;

	mov	ecx, 7
	lea	esi, DWORD PTR _tos$[ebp]
	mov	edi, OFFSET FLAT:_curr_state
	rep movsd

; 86   :        return( 1 );

	mov	eax, 1
	jmp	$L93463
$L93466:

; 87   :        }
; 88   :     if ( curr_state.bold && !tos.bold )

	cmp	DWORD PTR _curr_state+12, 0
	je	SHORT $L93467
	cmp	DWORD PTR _tos$[ebp+12], 0
	jne	SHORT $L93467

; 89   :        out.put( _T('}')) ;

	push	125					; 0000007dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 90   :     else if ( !curr_state.bold && tos.bold )

	jmp	SHORT $L93468
$L93467:
	cmp	DWORD PTR _curr_state+12, 0
	jne	SHORT $L93468
	cmp	DWORD PTR _tos$[ebp+12], 0
	je	SHORT $L93468

; 91   :        out.put( _T('{')) ;

	push	123					; 0000007bH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put
$L93468:

; 92   :     if ( curr_state.underscore && !tos.underscore )

	cmp	DWORD PTR _curr_state+16, 0
	je	SHORT $L93470
	cmp	DWORD PTR _tos$[ebp+16], 0
	jne	SHORT $L93470

; 93   :        out.put( _T('>')) ;

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 94   :     else if ( !curr_state.underscore && tos.underscore )

	jmp	SHORT $L93471
$L93470:
	cmp	DWORD PTR _curr_state+16, 0
	jne	SHORT $L93471
	cmp	DWORD PTR _tos$[ebp+16], 0
	je	SHORT $L93471

; 95   :        out.put( _T('<')) ;

	push	60					; 0000003cH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put
$L93471:

; 96   :     if ( curr_state.head && !tos.head )

	cmp	DWORD PTR _curr_state+20, 0
	je	SHORT $L93473
	cmp	DWORD PTR _tos$[ebp+20], 0
	jne	SHORT $L93473

; 97   :        out.put( _T(']')  );

	push	93					; 0000005dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 98   :     else if ( !curr_state.head && tos.head )

	jmp	SHORT $L93474
$L93473:
	cmp	DWORD PTR _curr_state+20, 0
	jne	SHORT $L93474
	cmp	DWORD PTR _tos$[ebp+20], 0
	je	SHORT $L93474

; 99   :        out.put( _T('[')  );

	push	91					; 0000005bH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put
$L93474:

; 100  :     curr_state = tos;

	mov	ecx, 7
	lea	esi, DWORD PTR _tos$[ebp]
	mov	edi, OFFSET FLAT:_curr_state
	rep movsd

; 101  :     return( 1 );

	mov	eax, 1
	jmp	SHORT $L93463
$L93465:

; 102  :     }
; 103  :  else
; 104  :     return( 0 );

	xor	eax, eax
$L93463:

; 105  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93920
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93920:
	DD	1
	DD	$L93919
$L93919:
	DD	-32					; ffffffe0H
	DD	28					; 0000001cH
	DD	$L93918
$L93918:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?pop_state@@YAHAAVStrbuff@@@Z ENDP			; pop_state
_TEXT	ENDS
EXTRN	?_get@Strbuff@@QAEEAAE@Z:NEAR			; Strbuff::_get
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z
_TEXT	SEGMENT
tv70 = -208						; size = 4
_ch$ = -5						; size = 1
_stream$ = 8						; size = 4
_cwp$ = 12						; size = 4
?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z PROC NEAR	; rtf_read, COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 273  :  _TUCHAR ch;
; 274  : 
; 275  :  stream._get( ch );

	lea	eax, DWORD PTR _ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?_get@Strbuff@@QAEEAAE@Z		; Strbuff::_get

; 276  :  if (stream.eof() )

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?eof@Strbuff@@QAEHXZ			; Strbuff::eof
	test	eax, eax
	je	SHORT $L93568

; 277  :     ch=_T('\0');

	mov	BYTE PTR _ch$[ebp], 0
$L93568:

; 278  :  switch( ch ) {

	movzx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 125		; 0000007dH
	ja	SHORT $L93577
	mov	ecx, DWORD PTR tv70[ebp]
	movzx	edx, BYTE PTR $L93923[ecx]
	jmp	DWORD PTR $L93927[edx*4]
$L93573:

; 279  : 	   case _T('\0'):
; 280  : 	    return( REOF );

	or	eax, -1
	jmp	SHORT $L93566
$L93574:

; 281  : 	    break;
; 282  :        case _T('\\')  :
; 283  : 	    return( get_code_word( stream, cwp ) );

	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	?get_code_word@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z ; get_code_word
	add	esp, 8
	jmp	SHORT $L93566
$L93575:

; 284  : 	    break;
; 285  :        case _T('{')  :
; 286  : 	    ++brace_state;

	mov	eax, DWORD PTR _brace_state
	add	eax, 1
	mov	DWORD PTR _brace_state, eax

; 287  : 	    return( ROBRA );

	mov	eax, -2					; fffffffeH
	jmp	SHORT $L93566
$L93576:

; 288  : 	    break;
; 289  :        case _T('}')  :
; 290  : 	    --brace_state;

	mov	eax, DWORD PTR _brace_state
	sub	eax, 1
	mov	DWORD PTR _brace_state, eax

; 291  : 	    return( RCBRA );

	mov	eax, -3					; fffffffdH
	jmp	SHORT $L93566
$L93577:

; 292  : 	    break;
; 293  :        default :
; 294  : 	    return( (int)ch );

	movzx	eax, BYTE PTR _ch$[ebp]
$L93566:

; 295  : 	    break;
; 296  :        }
; 297  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93926
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93926:
	DD	1
	DD	$L93925
$L93925:
	DD	-5					; fffffffbH
	DD	1
	DD	$L93924
$L93924:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	0
$L93927:
	DD	$L93573
	DD	$L93574
	DD	$L93575
	DD	$L93576
	DD	$L93577
$L93923:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z ENDP		; rtf_read
_TEXT	ENDS
PUBLIC	??_C@_0N@KMKIHNKG@?5?91234567890?$AA@		; `string'
EXTRN	@_RTC_Check_4_to_1@4:NEAR
EXTRN	_strchr:NEAR
;	COMDAT ??_C@_0N@KMKIHNKG@?5?91234567890?$AA@
CONST	SEGMENT
??_C@_0N@KMKIHNKG@?5?91234567890?$AA@ DB ' -1234567890', 00H ; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?get_code_word@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z
_TEXT	SEGMENT
tv67 = -268						; size = 4
_c$ = -68						; size = 4
_v$ = -56						; size = 4
_buf$ = -44						; size = 35
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_stream$ = 8						; size = 4
_cwp$ = 12						; size = 4
?get_code_word@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z PROC NEAR ; get_code_word, COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 204  :  TCHAR buf[35];
; 205  :  int v, c;
; 206  : 
; 207  :  c = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	movzx	eax, al
	mov	DWORD PTR _c$[ebp], eax

; 208  :  switch( c ) {

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	sub	ecx, 10					; 0000000aH
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 116		; 00000074H
	ja	SHORT $L93545
	mov	edx, DWORD PTR tv67[ebp]
	movzx	eax, BYTE PTR $L93931[edx]
	jmp	DWORD PTR $L93937[eax*4]
$L93538:

; 209  :        case _T('\\')  :
; 210  :        case _T('}')   :
; 211  :        case _T('{')   :
; 212  : 	    return( c );

	mov	eax, DWORD PTR _c$[ebp]
	jmp	$L93530
$L93539:

; 213  : 	    break;
; 214  :        case _T('*')   :
; 215  : 	    stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get

; 216  : 	    break;

	jmp	$L93535
$L93540:

; 217  : #ifndef _UNICODE
; 218  :        case _T('~')   :
; 219  : 	    return( _T(' ')  );

	mov	eax, 32					; 00000020H
	jmp	$L93530
$L93541:

; 220  : 	    break;
; 221  : #else
; 222  : 	   case _T('u')  :
; 223  : 	    v = read_int(stream);
; 224  : 		return( v );
; 225  : 	   break;
; 226  : #endif
; 227  :        case _T('\xa')  :
; 228  :        case _T('\xd')  :
; 229  : 	    return( REOL );

	mov	eax, -5					; fffffffbH
	jmp	$L93530
$L93542:

; 230  : 	    break;
; 231  :        case _T('_')  :
; 232  : 	    return( _T('-')  );

	mov	eax, 45					; 0000002dH
	jmp	$L93530
$L93543:

; 233  : 	    break;
; 234  :        case _T('\'')  :
; 235  : 	    v = read_hex2( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	?read_hex2@@YAHAAVStrbuff@@@Z		; read_hex2
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 236  : 	    return( v );

	mov	eax, DWORD PTR _v$[ebp]
	jmp	$L93530
$L93544:

; 237  : 	    break;
; 238  :        case _T('|')  :
; 239  : 	    break;

	jmp	$L93535
$L93545:

; 240  :        default :
; 241  : 	    stream.putback( c );

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 242  : 	    read_name( stream, buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	?read_name@@YAHAAVStrbuff@@PAD@Z	; read_name
	add	esp, 8

; 243  : 	    cwp->val = 1;

	mov	eax, DWORD PTR _cwp$[ebp]
	mov	DWORD PTR [eax+32], 1

; 244  : 	    _tcscpy( cwp->name, buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cwp$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 245  : 	    c = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	movzx	eax, al
	mov	DWORD PTR _c$[ebp], eax

; 246  : 	    if ( _tcschr( _T(" -1234567890"), c ) == NULL )

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@KMKIHNKG@?5?91234567890?$AA@
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93546

; 247  : 	       stream.putback( c );

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 248  : 	    else if ( c != _T(' ') ) {

	jmp	SHORT $L93548
$L93546:
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $L93548

; 249  : 	       stream.putback( c );

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback

; 250  : 	       if ( c != _T(' ') )

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $L93550

; 251  : 		  cwp->val = read_int( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	?read_int@@YAHAAVStrbuff@@@Z		; read_int
	add	esp, 4
	mov	ecx, DWORD PTR _cwp$[ebp]
	mov	DWORD PTR [ecx+32], eax
$L93550:

; 252  : 	       c = stream.get();

	mov	ecx, DWORD PTR _stream$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	movzx	eax, al
	mov	DWORD PTR _c$[ebp], eax

; 253  : 	       if ( c != _T(' ') )

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $L93548

; 254  : 		  stream.putback( c );

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	call	?putback@Strbuff@@QAEXD@Z		; Strbuff::putback
$L93548:

; 255  : 	       }
; 256  : 	    return( RCODE );

	mov	eax, -4					; fffffffcH
	jmp	SHORT $L93530
$L93535:

; 257  : 	    break;
; 258  :        }
; 259  :  return( 0 );

	xor	eax, eax
$L93530:

; 260  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93936
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93936:
	DD	1
	DD	$L93935
$L93935:
	DD	-44					; ffffffd4H
	DD	35					; 00000023H
	DD	$L93933
$L93933:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$L93937:
	DD	$L93541
	DD	$L93543
	DD	$L93539
	DD	$L93538
	DD	$L93542
	DD	$L93544
	DD	$L93540
	DD	$L93545
$L93931:
	DB	0
	DB	7
	DB	7
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	5
	DB	3
	DB	6
?get_code_word@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z ENDP	; get_code_word
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?set_caps@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?set_caps@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR ; set_caps, COMDAT

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 324  :  if ( cwp->val ) {

	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $L93603

; 325  :     curr_state.map_caps = 1;

	mov	DWORD PTR _curr_state, 1

; 326  :     }
; 327  :  else {

	jmp	SHORT $L93604
$L93603:

; 328  :     curr_state.map_caps = 0;

	mov	DWORD PTR _curr_state, 0
$L93604:

; 329  :     }
; 330  :  return( 0 );

	xor	eax, eax

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?set_caps@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; set_caps
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?set_inv@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?set_inv@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; set_inv, COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 335  :  if ( cwp->val ) {

	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $L93611

; 336  :     curr_state.map_inv = 1;

	mov	DWORD PTR _curr_state+4, 1

; 337  :     }
; 338  :  else {

	jmp	SHORT $L93612
$L93611:

; 339  :     curr_state.map_inv = 0;

	mov	DWORD PTR _curr_state+4, 0
$L93612:

; 340  :     }
; 341  :  return( 0 );

	xor	eax, eax

; 342  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?set_inv@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; set_inv
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?output_bold@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?output_bold@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR ; output_bold, COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 347  :  if ( cwp->val ) {

	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $L93619

; 348  :     if ( !curr_state.bold && !curr_state.head ) {

	cmp	DWORD PTR _curr_state+12, 0
	jne	SHORT $L93620
	cmp	DWORD PTR _curr_state+20, 0
	jne	SHORT $L93620

; 349  :        out.put( _T('{')) ;

	push	123					; 0000007bH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 350  :        curr_state.bold = 1;

	mov	DWORD PTR _curr_state+12, 1
$L93620:

; 351  :        }
; 352  :     }
; 353  :  else {

	jmp	SHORT $L93621
$L93619:

; 354  :     if ( curr_state.bold && !curr_state.head) {

	cmp	DWORD PTR _curr_state+12, 0
	je	SHORT $L93621
	cmp	DWORD PTR _curr_state+20, 0
	jne	SHORT $L93621

; 355  :        out.put( _T('}')) ;

	push	125					; 0000007dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 356  :        curr_state.bold = 0;

	mov	DWORD PTR _curr_state+12, 0
$L93621:

; 357  :        }
; 358  :     }
; 359  :  return( 0 );

	xor	eax, eax

; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?output_bold@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; output_bold
_TEXT	ENDS
PUBLIC	??_C@_02BLFNBMOO@qc?$AA@			; `string'
PUBLIC	??_C@_02MKJPKHKH@qj?$AA@			; `string'
PUBLIC	??_C@_02JMMFAACB@ql?$AA@			; `string'
PUBLIC	??_C@_02EIPGLLEK@fs?$AA@			; `string'
;	COMDAT ??_C@_02BLFNBMOO@qc?$AA@
CONST	SEGMENT
??_C@_02BLFNBMOO@qc?$AA@ DB 'qc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKJPKHKH@qj?$AA@
CONST	SEGMENT
??_C@_02MKJPKHKH@qj?$AA@ DB 'qj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFAACB@ql?$AA@
CONST	SEGMENT
??_C@_02JMMFAACB@ql?$AA@ DB 'ql', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EIPGLLEK@fs?$AA@
CONST	SEGMENT
??_C@_02EIPGLLEK@fs?$AA@ DB 'fs', 00H			; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR ; output_head, COMDAT

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 365  :  if ( !_tcsicmp( cwp->name, _T("qc") ) ) {

	push	OFFSET FLAT:??_C@_02BLFNBMOO@qc?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93629

; 366  :     if ( !curr_state.head ) {

	cmp	DWORD PTR _curr_state+20, 0
	jne	SHORT $L93631

; 367  :        out.put( _T('[')) ;

	push	91					; 0000005bH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 368  :        curr_state.head = 1;

	mov	DWORD PTR _curr_state+20, 1

; 369  :        curr_state.size=14;

	mov	DWORD PTR _curr_state+24, 14		; 0000000eH
$L93631:

; 370  :        }
; 371  :     }
; 372  :  else if ( !_tcsicmp( cwp->name, _T("qj") ) || !_tcsicmp( cwp->name, _T("ql") ) ) {

	jmp	SHORT $L93632
$L93629:
	push	OFFSET FLAT:??_C@_02MKJPKHKH@qj?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L93634
	push	OFFSET FLAT:??_C@_02JMMFAACB@ql?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93632
$L93634:

; 373  :     if ( curr_state.head ) {

	cmp	DWORD PTR _curr_state+20, 0
	je	SHORT $L93632

; 374  :        out.put(_T(']')) ;

	push	93					; 0000005dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 375  :        curr_state.head = 0;

	mov	DWORD PTR _curr_state+20, 0

; 376  :        curr_state.size = 12;

	mov	DWORD PTR _curr_state+24, 12		; 0000000cH
$L93632:

; 377  :        }
; 378  :     }
; 379  :  if ( !_tcsicmp( cwp->name, _T("fs") ) ) {

	push	OFFSET FLAT:??_C@_02EIPGLLEK@fs?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93638

; 380  : 	if ( curr_state.head && cwp->val == 24 ) {

	cmp	DWORD PTR _curr_state+20, 0
	je	SHORT $L93640
	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 24			; 00000018H
	jne	SHORT $L93640

; 381  : 	   out.put(_T(']')) ;

	push	93					; 0000005dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 382  :        curr_state.head = 0;

	mov	DWORD PTR _curr_state+20, 0

; 383  :        curr_state.size = 12;

	mov	DWORD PTR _curr_state+24, 12		; 0000000cH

; 384  :        }
; 385  : 	else if ( !curr_state.head && cwp->val == 28 ) {

	jmp	SHORT $L93638
$L93640:
	cmp	DWORD PTR _curr_state+20, 0
	jne	SHORT $L93638
	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 28			; 0000001cH
	jne	SHORT $L93638

; 386  :        out.put( _T('[')) ;

	push	91					; 0000005bH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 387  :        curr_state.head = 1;

	mov	DWORD PTR _curr_state+20, 1

; 388  :        curr_state.size=14;

	mov	DWORD PTR _curr_state+24, 14		; 0000000eH
$L93638:

; 389  :        }
; 390  :     }
; 391  :  
; 392  :  return( 0 );

	xor	eax, eax

; 393  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?output_head@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; output_head
_TEXT	ENDS
PUBLIC	??_C@_06LMHBEHJN@ulnone?$AA@			; `string'
;	COMDAT ??_C@_06LMHBEHJN@ulnone?$AA@
CONST	SEGMENT
??_C@_06LMHBEHJN@ulnone?$AA@ DB 'ulnone', 00H		; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR ; output_us, COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 398  :  if ( !_tcsicmp( cwp->name, _T("ulnone") ) && curr_state.underscore ) {

	push	OFFSET FLAT:??_C@_06LMHBEHJN@ulnone?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93649
	cmp	DWORD PTR _curr_state+16, 0
	je	SHORT $L93649

; 399  :     out.put( _T('>')) ;

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 400  :     curr_state.underscore = 0;

	mov	DWORD PTR _curr_state+16, 0

; 401  :     return( 0 );

	xor	eax, eax
	jmp	SHORT $L93648
$L93649:

; 402  :     }
; 403  :  if ( cwp->val ) {

	mov	eax, DWORD PTR _cwp$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $L93651

; 404  :     if ( !curr_state.underscore ) {

	cmp	DWORD PTR _curr_state+16, 0
	jne	SHORT $L93652

; 405  :        out.put( _T('<')) ;

	push	60					; 0000003cH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 406  :        curr_state.underscore = 1;

	mov	DWORD PTR _curr_state+16, 1
$L93652:

; 407  :        }
; 408  :     }
; 409  :  else {

	jmp	SHORT $L93653
$L93651:

; 410  :     if ( curr_state.underscore ) {

	cmp	DWORD PTR _curr_state+16, 0
	je	SHORT $L93653

; 411  :        out.put( _T('>')) ;

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 412  :        curr_state.underscore = 0;

	mov	DWORD PTR _curr_state+16, 0
$L93653:

; 413  :        }
; 414  :     }
; 415  :  return( 0 );

	xor	eax, eax
$L93648:

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?output_us@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; output_us
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; plain, COMDAT

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 420  :  if ( curr_state.bold ) {

	cmp	DWORD PTR _curr_state+12, 0
	je	SHORT $L93661

; 421  :     out.put( _T('}')) ;

	push	125					; 0000007dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 422  :     curr_state.bold = 0;

	mov	DWORD PTR _curr_state+12, 0
$L93661:

; 423  :     }
; 424  :  if ( curr_state.underscore ) {

	cmp	DWORD PTR _curr_state+16, 0
	je	SHORT $L93662

; 425  :     out.put( _T('>')  );

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 426  :     curr_state.underscore = 0;

	mov	DWORD PTR _curr_state+16, 0
$L93662:

; 427  :     }
; 428  :  if ( curr_state.head ) {

	cmp	DWORD PTR _curr_state+20, 0
	je	SHORT $L93663

; 429  :     out.put( _T(']')  );

	push	93					; 0000005dH
	mov	ecx, DWORD PTR _out$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 430  :     curr_state.head = 0;

	mov	DWORD PTR _curr_state+20, 0

; 431  :     curr_state.size = 12;

	mov	DWORD PTR _curr_state+24, 12		; 0000000cH
$L93663:

; 432  :     }
; 433  : 
; 434  :  return( 1 );

	mov	eax, 1

; 435  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?plain@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; plain
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; font, COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$L93671:

; 439  :  while (in.get() != _T(';')) ;

	mov	ecx, DWORD PTR _in$[ebp]
	call	?get@Strbuff@@QAEEXZ			; Strbuff::get
	movzx	eax, al
	cmp	eax, 59					; 0000003bH
	je	SHORT $L93672
	jmp	SHORT $L93671
$L93672:

; 440  :  return( 1 );

	mov	eax, 1

; 441  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?font@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP		; font
_TEXT	ENDS
PUBLIC	??_C@_03OBJIDKBM@par?$AA@			; `string'
;	COMDAT ??_C@_03OBJIDKBM@par?$AA@
CONST	SEGMENT
??_C@_03OBJIDKBM@par?$AA@ DB 'par', 00H			; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_cwp$ = 16						; size = 4
_s$ = 20						; size = 4
?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z PROC NEAR	; output, COMDAT

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 446  :  if ( !(!_tcsicmp(cwp->name,_T("par")) && curr_state.head==1) )

	push	OFFSET FLAT:??_C@_03OBJIDKBM@par?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L93680
	cmp	DWORD PTR _curr_state+20, 1
	je	SHORT $L93679
$L93680:

; 447  : 	out.puts( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	?puts@Strbuff@@QAEXPBD@Z		; Strbuff::puts

; 448  :  else if (_tcsicmp(cwp->name,_T("par")))

	jmp	SHORT $L93682
$L93679:
	push	OFFSET FLAT:??_C@_03OBJIDKBM@par?$AA@
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L93682

; 449  :     out.puts(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	?puts@Strbuff@@QAEXPBD@Z		; Strbuff::puts
$L93682:

; 450  :  return( 1 );

	mov	eax, 1

; 451  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?output@@YAHAAVStrbuff@@0PAUCODE_WORD@@PAD@Z ENDP	; output
_TEXT	ENDS
PUBLIC	?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z ; RTFToAst
PUBLIC	??_C@_02MLFFEHBF@?$HO?5?$AA@			; `string'
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??0Strbuff@@QAE@XZ				; Strbuff::Strbuff
PUBLIC	??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; Strbuff::Strbuff
PUBLIC	??1Strbuff@@UAE@XZ				; Strbuff::~Strbuff
PUBLIC	?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; Strbuff::getstr
EXTRN	_islower:NEAR
EXTRN	_toupper:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$1
__ehfuncinfo$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_02MLFFEHBF@?$HO?5?$AA@
CONST	SEGMENT
??_C@_02MLFFEHBF@?$HO?5?$AA@ DB '~ ', 00H		; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z
_TEXT	SEGMENT
tv75 = -632						; size = 4
$T93960 = -624						; size = 4
_instream$ = -420					; size = 168
_outstream$ = -244					; size = 168
_c$ = -68						; size = 4
_cw$ = -56						; size = 36
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z PROC NEAR ; RTFToAst, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 620				; 0000026cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-632]
	mov	ecx, 155				; 0000009bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T93960[ebp], 0

; 468  :  CODE_WORD cw;
; 469  :  int c;
; 470  :  Strbuff outstream = Strbuff();

	lea	ecx, DWORD PTR _outstream$[ebp]
	call	??0Strbuff@@QAE@XZ			; Strbuff::Strbuff
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 471  :  Strbuff instream = Strbuff(str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	lea	ecx, DWORD PTR _instream$[ebp]
	call	??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; Strbuff::Strbuff
	mov	BYTE PTR __$EHRec$[ebp+8], 2
$L93709:

; 472  : 
; 473  :  while ( ( c = rtf_read( instream, &cw ) ) != REOF ) {

	lea	eax, DWORD PTR _cw$[ebp]
	push	eax
	lea	ecx, DWORD PTR _instream$[ebp]
	push	ecx
	call	?rtf_read@@YAHAAVStrbuff@@PAUCODE_WORD@@@Z ; rtf_read
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], -1
	je	$L93710

; 474  :        switch( c ) {

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	add	ecx, 5
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 98			; 00000062H
	ja	$L93722
	mov	edx, DWORD PTR tv75[ebp]
	movzx	eax, BYTE PTR $L93966[edx]
	jmp	DWORD PTR $L93975[eax*4]
$L93715:

; 475  : 		 case _T('<'):
; 476  : 		 case _T('>'):
; 477  : 	     case _T('['):
; 478  : 		 case _T(']'):
; 479  :              outstream.put(_T('~')) ;

	push	126					; 0000007eH
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 480  : 			 outstream.put(c);

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 481  : 			 break;

	jmp	$L93712
$L93716:

; 482  :          case ROBRA :
; 483  : 		  push_state();

	call	?push_state@@YAHXZ			; push_state

; 484  : 		  break;

	jmp	$L93712
$L93717:

; 485  : 	     case RCBRA :
; 486  : 		  pop_state( outstream );

	lea	eax, DWORD PTR _outstream$[ebp]
	push	eax
	call	?pop_state@@YAHAAVStrbuff@@@Z		; pop_state
	add	esp, 4

; 487  : 		  break;

	jmp	$L93712
$L93718:

; 488  : 	     case RCODE :
; 489  : 		  do_code( &cw, instream, outstream );

	lea	eax, DWORD PTR _outstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _instream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cw$[ebp]
	push	edx
	call	?do_code@@YAHPAUCODE_WORD@@AAVStrbuff@@1@Z ; do_code
	add	esp, 12					; 0000000cH

; 490  : 		  break;

	jmp	$L93712
$L93719:

; 491  : 	     case REOL :
; 492  : 		  outstream.put( _T('\n')) ;

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 493  : 		  break;

	jmp	$L93712
$L93720:

; 494  : 	     case 9 :
; 495  : 		  outstream.put( _T('|')  );

	push	124					; 0000007cH
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 496  : 		  break;

	jmp	$L93712
$L93721:

; 497  : 	     case 0x0a :
; 498  : 	     case 0x0d :
; 499  : 		  break;

	jmp	$L93712
$L93722:

; 500  : #ifdef _UNICODE
; 501  : 	     case _T('^')  :
; 502  : 		  outstream.put( _T('^')) ;
; 503  : 		  break;
; 504  : #endif
; 505  : 	     default :
; 506  : 		  if ( !curr_state.map_inv ) {

	cmp	DWORD PTR _curr_state+4, 0
	jne	$L93712

; 507  : 		     if ( c == _T(' ')  && curr_state.hi_char ) {

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jne	SHORT $L93724
	cmp	DWORD PTR _curr_state+8, 0
	je	SHORT $L93724

; 508  : 			curr_state.hi_char = 0;

	mov	DWORD PTR _curr_state+8, 0

; 509  : 			outstream.puts( _T("~ ") );

	push	OFFSET FLAT:??_C@_02MLFFEHBF@?$HO?5?$AA@
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?puts@Strbuff@@QAEXPBD@Z		; Strbuff::puts

; 510  : 			}
; 511  : 		     else if ( curr_state.map_caps && _istascii( c ) && !_istlower( c ) )

	jmp	$L93712
$L93724:
	cmp	DWORD PTR _curr_state, 0
	je	SHORT $L93728
	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L93728
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_islower
	add	esp, 4
	test	eax, eax
	jne	SHORT $L93728

; 512  : 			outstream.put( _totupper( c ) );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_toupper
	add	esp, 4
	mov	ecx, eax
	call	@_RTC_Check_4_to_1@4
	push	eax
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 513  : 		     else if ( _istascii( c ) )

	jmp	SHORT $L93712
$L93728:
	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L93731

; 514  : 			outstream.put( c);

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 515  : 		     else {

	jmp	SHORT $L93712
$L93731:

; 516  : #ifndef _UNICODE 
; 517  : 			outstream.put( _T('~')) ;

	push	126					; 0000007eH
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 518  : 			outstream.put( c);

	mov	ecx, DWORD PTR _c$[ebp]
	call	@_RTC_Check_4_to_1@4
	push	eax
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?put@Strbuff@@QAEXD@Z			; Strbuff::put

; 519  : 			curr_state.hi_char = 1;

	mov	DWORD PTR _curr_state+8, 1
$L93712:

; 520  : #else
; 521  : 		    outstream.put( c); 
; 522  : #endif
; 523  : 			 }
; 524  : 		     }
; 525  : 		     break;
; 526  : 	     }
; 527  :        }

	jmp	$L93709
$L93710:

; 528  :  return( outstream.getstr() );

	lea	ecx, DWORD PTR _outstream$[ebp]
	call	?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; Strbuff::getstr
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
	mov	eax, DWORD PTR $T93960[ebp]
	or	eax, 1
	mov	DWORD PTR $T93960[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _instream$[ebp]
	call	??1Strbuff@@UAE@XZ			; Strbuff::~Strbuff
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _outstream$[ebp]
	call	??1Strbuff@@UAE@XZ			; Strbuff::~Strbuff
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 529  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L93974
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 632				; 00000278H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L93974:
	DD	3
	DD	$L93973
$L93973:
	DD	-56					; ffffffc8H
	DD	36					; 00000024H
	DD	$L93967
	DD	-244					; ffffff0cH
	DD	168					; 000000a8H
	DD	$L93968
	DD	-420					; fffffe5cH
	DD	168					; 000000a8H
	DD	$L93969
$L93969:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$L93968:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$L93967:
	DB	99					; 00000063H
	DB	119					; 00000077H
	DB	0
$L93975:
	DD	$L93719
	DD	$L93718
	DD	$L93717
	DD	$L93716
	DD	$L93720
	DD	$L93721
	DD	$L93715
	DD	$L93722
$L93966:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	4
	DB	5
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
	DB	7
	DB	6
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
	DB	7
	DB	6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$0:
	lea	ecx, DWORD PTR _outstream$[ebp]
	jmp	??1Strbuff@@UAE@XZ			; Strbuff::~Strbuff
__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$1:
	lea	ecx, DWORD PTR _instream$[ebp]
	jmp	??1Strbuff@@UAE@XZ			; Strbuff::~Strbuff
__unwindfunclet$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z$2:
	mov	eax, DWORD PTR $T93960[ebp]
	and	eax, 1
	je	$L93961
	and	DWORD PTR $T93960[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
$L93961:
	ret	0
__ehhandler$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?RTFToAst@@YA?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAV12@@Z ENDP ; RTFToAst
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??_7Strbuff@@6B@				; Strbuff::`vftable'
PUBLIC	??_GStrbuff@@UAEPAXI@Z				; Strbuff::`scalar deleting destructor'
EXTRN	??_EStrbuff@@UAEPAXI@Z:NEAR			; Strbuff::`vector deleting destructor'
;	COMDAT ??_7Strbuff@@6B@
; File c:\astrow32dev\tbt32\strbuff.h
CONST	SEGMENT
??_7Strbuff@@6B@ DD FLAT:??_EStrbuff@@UAEPAXI@Z		; Strbuff::`vftable'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??0Strbuff@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Strbuff@@QAE@XZ PROC NEAR				; Strbuff::Strbuff, COMDAT
; _this$ = ecx

; 20   : 	Strbuff() { len = 0; index=0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7Strbuff@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Strbuff@@QAE@XZ ENDP					; Strbuff::Strbuff
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0
__ehfuncinfo$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCcsu /ZI
xdata$x	ENDS
;	COMDAT ??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; Strbuff::Strbuff, COMDAT
; _this$ = ecx

; 21   : 	Strbuff(CString &s) { str=s; index=0; len=s.GetLength(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7Strbuff@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0
	mov	ecx, DWORD PTR _s$[ebp]
	call	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+156], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	jmp	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
__ehhandler$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0Strbuff@@QAE@AAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; Strbuff::Strbuff
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??1Strbuff@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Strbuff@@UAE@XZ PROC NEAR				; Strbuff::~Strbuff, COMDAT
; _this$ = ecx

; 22   : 	virtual ~Strbuff() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7Strbuff@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Strbuff@@UAE@XZ ENDP					; Strbuff::~Strbuff
_TEXT	ENDS
PUBLIC	?flush@Strbuff@@QAEXXZ				; Strbuff::flush
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; Strbuff::getstr, COMDAT
; _this$ = ecx

; 25   : 	CString &getstr() { flush(); return str; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?flush@Strbuff@@QAEXXZ			; Strbuff::flush
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 164				; 000000a4H
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getstr@Strbuff@@QAEAAV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; Strbuff::getstr
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?flush@Strbuff@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?flush@Strbuff@@QAEXXZ PROC NEAR			; Strbuff::flush, COMDAT
; _this$ = ecx

; 24   : 	void flush() { str += buf; len=0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?flush@Strbuff@@QAEXXZ ENDP				; Strbuff::flush
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??_GStrbuff@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GStrbuff@@UAEPAXI@Z PROC NEAR			; Strbuff::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Strbuff@@UAE@XZ			; Strbuff::~Strbuff
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L93000
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L93000:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GStrbuff@@UAEPAXI@Z ENDP				; Strbuff::`scalar deleting destructor'
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\astrow32dev\tbt32\rtftoast.cpp
_TEXT	ENDS
;	COMDAT ?push_state@@YAHXZ
_TEXT	SEGMENT
?push_state@@YAHXZ PROC NEAR				; push_state, COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 180  :  if ( state_sp < STATE_CNT-1 ) {

	cmp	DWORD PTR _state_sp, 24			; 00000018H
	jge	SHORT $L93514

; 181  :     state_stack[++state_sp] = curr_state;

	mov	eax, DWORD PTR _state_sp
	add	eax, 1
	mov	DWORD PTR _state_sp, eax
	mov	edi, DWORD PTR _state_sp
	imul	edi, 28					; 0000001cH
	add	edi, OFFSET FLAT:_state_stack
	mov	ecx, 7
	mov	esi, OFFSET FLAT:_curr_state
	rep movsd

; 182  :     return( 1 );

	mov	eax, 1
	jmp	SHORT $L93513
$L93514:

; 183  :     }
; 184  :  else
; 185  :     return( 0 );

	xor	eax, eax
$L93513:

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?push_state@@YAHXZ ENDP					; push_state
_TEXT	ENDS
EXTRN	_strcmpi:NEAR
EXTRN	_lfind:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?do_code@@YAHPAUCODE_WORD@@AAVStrbuff@@1@Z
_TEXT	SEGMENT
_cwd$ = -8						; size = 4
_cwp$ = 8						; size = 4
_in$ = 12						; size = 4
_out$ = 16						; size = 4
?do_code@@YAHPAUCODE_WORD@@AAVStrbuff@@1@Z PROC NEAR	; do_code, COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 457  :  CWDO *cwd;
; 458  : 
; 459  :  cwd = (CWDO *)lfind( cwp->name, cwd_array, (unsigned int *)&cwd_count, sizeof( CWDO ), (matchfunc)strcmpi );

	push	OFFSET FLAT:_strcmpi
	push	40					; 00000028H
	push	OFFSET FLAT:_cwd_count
	push	OFFSET FLAT:_cwd_array
	mov	eax, DWORD PTR _cwp$[ebp]
	push	eax
	call	_lfind
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cwd$[ebp], eax

; 460  :  if ( cwd == NULL )

	cmp	DWORD PTR _cwd$[ebp], 0
	jne	SHORT $L93697

; 461  :     return( 0 );

	xor	eax, eax
	jmp	SHORT $L93691
$L93697:

; 462  :  return( cwd->df( in, out, cwp, cwd->out ) );

	mov	esi, esp
	mov	eax, DWORD PTR _cwd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _cwp$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cwd$[ebp]
	call	DWORD PTR [edx+36]
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$L93691:

; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?do_code@@YAHPAUCODE_WORD@@AAVStrbuff@@1@Z ENDP		; do_code
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_strSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 967  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 		CThisSimpleString::operator=( strSrc );

	mov	eax, DWORD PTR _strSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ; ATL::CSimpleStringT<char,0>::operator=

; 969  : 
; 970  : 		return( *this );

	mov	eax, DWORD PTR _this$[ebp]

; 971  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator+=
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszSrc$ = 8						; size = 4
??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=, COMDAT
; _this$ = ecx

; 1042 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1043 : 		CThisSimpleString::operator+=( pszSrc );

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ; ATL::CSimpleStringT<char,0>::operator+=

; 1044 : 
; 1045 : 		return( *this );

	mov	eax, DWORD PTR _this$[ebp]

; 1046 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator+=
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
PUBLIC	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_pNewData$93745 = -44					; size = 4
_pOldData$ = -32					; size = 4
_pSrcData$ = -20					; size = 4
_this$ = -8						; size = 4
_strSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 273  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 		CStringData* pSrcData = strSrc.GetData();

	mov	ecx, DWORD PTR _strSrc$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pSrcData$[ebp], eax

; 275  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 276  : 		if( pSrcData != pOldData)

	mov	eax, DWORD PTR _pSrcData$[ebp]
	cmp	eax, DWORD PTR _pOldData$[ebp]
	je	SHORT $L93741

; 277  : 		{
; 278  : 			if( pOldData->IsLocked() || pSrcData->pStringMgr != pOldData->pStringMgr )

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?IsLocked@CStringData@ATL@@QBE_NXZ	; ATL::CStringData::IsLocked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L93743
	mov	eax, DWORD PTR _pSrcData$[ebp]
	mov	ecx, DWORD PTR _pOldData$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $L93742
$L93743:

; 279  : 			{
; 280  : 				SetString( strSrc.GetString(), strSrc.GetLength() );

	mov	ecx, DWORD PTR _strSrc$[ebp]
	call	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
	push	eax
	mov	ecx, DWORD PTR _strSrc$[ebp]
	call	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 281  : 			}
; 282  : 			else

	jmp	SHORT $L93741
$L93742:

; 283  : 			{
; 284  : 				CStringData* pNewData = CloneData( pSrcData );

	mov	eax, DWORD PTR _pSrcData$[ebp]
	push	eax
	call	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
	add	esp, 4
	mov	DWORD PTR _pNewData$93745[ebp], eax

; 285  : 				pOldData->Release();

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 286  : 				Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$93745[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L93741:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		return( *this );

	mov	eax, DWORD PTR _this$[ebp]

; 291  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z	; ATL::CSimpleStringT<char,0>::Append
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszSrc$ = 8						; size = 4
??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator+=, COMDAT
; _this$ = ecx

; 336  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 337  : 		Append( pszSrc );

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::Append

; 338  : 
; 339  : 		return( *this );

	mov	eax, DWORD PTR _this$[ebp]

; 340  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator+=
_TEXT	ENDS
PUBLIC	?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z	; ATL::CSimpleStringT<char,0>::Append
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszSrc$ = 8						; size = 4
?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Append, COMDAT
; _this$ = ecx

; 383  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		Append( pszSrc, StringLength( pszSrc ) );

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	call	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::Append

; 385  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::Append
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszBuffer$ = -56					; size = 4
_nNewLength$ = -44					; size = 4
_nOldLength$ = -32					; size = 4
_nOffset$ = -20						; size = 4
_this$ = -8						; size = 4
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Append, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 		// See comment in SetString() about why we do this
; 389  : 		UINT_PTR nOffset = pszSrc-GetString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _nOffset$[ebp], ecx

; 390  : 
; 391  : 		UINT nOldLength = GetLength();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
	mov	DWORD PTR _nOldLength$[ebp], eax

; 392  : 		int nNewLength = nOldLength+nLength;

	mov	eax, DWORD PTR _nOldLength$[ebp]
	add	eax, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nNewLength$[ebp], eax

; 393  : 		PXSTR pszBuffer = GetBuffer( nNewLength );

	mov	eax, DWORD PTR _nNewLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
	mov	DWORD PTR _pszBuffer$[ebp], eax

; 394  : 		if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _nOffset$[ebp]
	cmp	eax, DWORD PTR _nOldLength$[ebp]
	ja	SHORT $L93756

; 395  : 		{
; 396  : 			pszSrc = pszBuffer+nOffset;

	mov	eax, DWORD PTR _pszBuffer$[ebp]
	add	eax, DWORD PTR _nOffset$[ebp]
	mov	DWORD PTR _pszSrc$[ebp], eax
$L93756:

; 397  : 			// No need to call CopyCharsOverlapped, since the destination is
; 398  : 			// beyond the end of the original buffer
; 399  : 		}
; 400  : 		CopyChars( pszBuffer+nOldLength, pszSrc, nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	add	edx, DWORD PTR _nOldLength$[ebp]
	push	edx
	call	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
	add	esp, 12					; 0000000cH

; 401  : 		ReleaseBufferSetLength( nNewLength );

	mov	eax, DWORD PTR _nNewLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength

; 402  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Append@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::Append
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 75   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 		return nRefs < 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setl	cl
	call	@_RTC_Check_4_to_1@4

; 77   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@ ; `string'
PUBLIC	??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@	; `string'
EXTRN	__CrtDbgReport:NEAR
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@ DB 'nRefs != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
CONST	SEGMENT
??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@ DB 'c:\program '
	DB	'files\microsoft visual studio .net 2003\vc7\atlmfc\include\at'
	DB	'lsimpstr.h', 00H				; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		ATLASSERT( nRefs != 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $L94021
	push	OFFSET FLAT:??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
	push	0
	push	93					; 0000005dH
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94021
	int	3
$L94021:

; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
	dec	ecx
	test	ecx, ecx
	jg	SHORT $L25707

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L25707:

; 98   : 		}
; 99   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	call	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 797  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_strSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 814  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _strSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 815  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 962  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 963  : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ	; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 500  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 501  : 		return( GetData()->nDataLength );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	eax, DWORD PTR [eax+4]

; 502  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@ DB 'pStringMgr != 0', 00H ; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pData$ = -20						; size = 4
_this$ = -8						; size = 4
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );

	cmp	DWORD PTR _pStringMgr$[ebp], 0
	jne	SHORT $L94033
	push	OFFSET FLAT:??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
	push	0
	push	212					; 000000d4H
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94033
	int	3
$L94033:

; 213  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR _pStringMgr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	call	DWORD PTR [edx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pData$[ebp], eax

; 214  : 		Attach( pData );

	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 215  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_pNewData$ = -32					; size = 4
_pSrcData$ = -20					; size = 4
_this$ = -8						; size = 4
_strSrc$ = 8						; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 217  : 	CSimpleStringT( const CSimpleStringT& strSrc )

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	{
; 219  : 		CStringData* pSrcData = strSrc.GetData();

	mov	ecx, DWORD PTR _strSrc$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pSrcData$[ebp], eax

; 220  : 		CStringData* pNewData = CloneData( pSrcData );

	mov	eax, DWORD PTR _pSrcData$[ebp]
	push	eax
	call	?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ; ATL::CSimpleStringT<char,0>::CloneData
	add	esp, 4
	mov	DWORD PTR _pNewData$[ebp], eax

; 221  : 		Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 222  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
_pData$ = -20						; size = 4
_this$ = -8						; size = 4
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 262  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 		CStringData* pData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pData$[ebp], eax

; 264  : 		pData->Release();

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 265  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

	mov	eax, DWORD PTR _nMinBufferLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite

; 491  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@ DB 'nNewLength >= 0', 00H ; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 546  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );

	cmp	DWORD PTR _nNewLength$[ebp], 0
	jge	SHORT $L94042
	push	OFFSET FLAT:??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
	push	0
	push	547					; 00000223H
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94042
	int	3
$L94042:

; 548  : 		SetLength( nNewLength );

	mov	eax, DWORD PTR _nNewLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 549  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 677  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 678  : 		if( psz == NULL )

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L92819

; 679  : 		{
; 680  : 			return( 0 );

	xor	eax, eax
	jmp	SHORT $L92818
$L92819:

; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
$L92818:

; 683  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 730  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, 16					; 00000010H

; 732  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nTooShort$ = -44					; size = 4
_nShared$ = -32						; size = 4
_pOldData$ = -20					; size = 4
_this$ = -8						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 735  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, 1
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _nShared$[ebp], ecx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nTooShort$[ebp], ecx

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	mov	eax, DWORD PTR _nShared$[ebp]
	or	eax, DWORD PTR _nTooShort$[ebp]
	jge	SHORT $L92828

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L92828:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 744  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@ ; `string'
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@ DB 'nLength >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT
??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@ DB 'n'
	DB	'Length <= GetData()->nAllocLength', 00H	; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 789  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 790  : 		ATLASSERT( nLength >= 0 );

	cmp	DWORD PTR _nLength$[ebp], 0
	jge	SHORT $L94051
	push	OFFSET FLAT:??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
	push	0
	push	790					; 00000316H
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94051
	int	3
$L94051:

; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	ecx, DWORD PTR _nLength$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $L94052
	push	OFFSET FLAT:??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
	push	0
	push	791					; 00000317H
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94052
	int	3
$L94052:

; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	DWORD PTR _nLength$[ebp], 0
	jl	SHORT $L92836
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	ecx, DWORD PTR _nLength$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $L92835
$L92836:

; 794  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L92835:

; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	ecx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 797  : 		m_pszData[nLength] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nLength$[ebp]
	mov	BYTE PTR [ecx+edx], 0
$L94050:

; 798  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??AtlThrow@ATL@@YGXJ@Z@4JA	; `ATL::AtlThrow'::`2'::__LINE__Var
PUBLIC	??_C@_0FC@IPKABFFL@c?3?2program?5files?2microsoft?5visua@ ; `string'
PUBLIC	??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ ; `string'
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
EXTRN	?atlTraceException@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceException
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
CONST	SEGMENT
??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ DB 'AtlThrow: hr '
	DB	'= 0x%x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlThrow@ATL@@YGXJ@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlThrow@ATL@@YGXJ@Z@4JA DD 03dH	; `ATL::AtlThrow'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FC@IPKABFFL@c?3?2program?5files?2microsoft?5visua@
CONST	SEGMENT
??_C@_0FC@IPKABFFL@c?3?2program?5files?2microsoft?5visua@ DB 'c:\program '
	DB	'files\microsoft visual studio .net 2003\vc7\atlmfc\include\at'
	DB	'lexcept.h', 00H				; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T94055 = -204						; size = 8
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceException@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceException
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AtlThrow@ATL@@YGXJ@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET FLAT:??_C@_0FC@IPKABFFL@c?3?2program?5files?2microsoft?5visua@
	lea	ecx, DWORD PTR $T94055[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

	cmp	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH
	jne	SHORT $L24989

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

	call	?AfxThrowMemoryException@@YGXXZ		; AfxThrowMemoryException
$L24989:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?AfxThrowOleException@@YGXJ@Z		; AfxThrowOleException
$L94054:

; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );
; 74   : #endif
; 75   : };

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 162  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 163  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
	call	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z	; ATL::CTrace::TraceV
	add	esp, 28					; 0000001cH

; 164  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 165  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_AtlTraceVA
	add	esp, 28					; 0000001cH

; 123  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
_TEXT	ENDS
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:NEAR ; AfxGetStringManager
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxstr.h
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC NEAR ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 49   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 50   : 		return( AfxGetStringManager() );

	call	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager

; 51   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Odt /RTCcsu /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 711  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 713  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 65   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 		return (this+1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nNewLength$92884 = -32					; size = 4
_pOldData$ = -20					; size = 4
_this$ = -8						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 746  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 747  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 748  : 		if( pOldData->nDataLength > nLength )

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jle	SHORT $L92880

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nLength$[ebp], ecx
$L92880:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?IsShared@CStringData@ATL@@QBE_NXZ	; ATL::CStringData::IsShared
	movzx	eax, al
	test	eax, eax
	je	SHORT $L92881

; 753  : 		{
; 754  : 			Fork( nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

	jmp	SHORT $L92878
$L92881:
	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jge	SHORT $L92878

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nNewLength$92884[ebp], ecx

; 760  : 			if( nNewLength > 1024 )

	cmp	DWORD PTR _nNewLength$92884[ebp], 1024	; 00000400H
	jle	SHORT $L92885

; 761  : 			{
; 762  : 				nNewLength += 1024;

	mov	eax, DWORD PTR _nNewLength$92884[ebp]
	add	eax, 1024				; 00000400H
	mov	DWORD PTR _nNewLength$92884[ebp], eax

; 763  : 			}
; 764  : 			else

	jmp	SHORT $L92886
$L92885:

; 765  : 			{
; 766  : 				nNewLength *= 2;

	mov	eax, DWORD PTR _nNewLength$92884[ebp]
	shl	eax, 1
	mov	DWORD PTR _nNewLength$92884[ebp], eax
$L92886:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

	mov	eax, DWORD PTR _nNewLength$92884[ebp]
	cmp	eax, DWORD PTR _nLength$[ebp]
	jge	SHORT $L92887

; 769  : 			{
; 770  : 				nNewLength = nLength;

	mov	eax, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nNewLength$92884[ebp], eax
$L92887:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

	mov	eax, DWORD PTR _nNewLength$92884[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L92878:

; 773  : 		}
; 774  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 79   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		return( nRefs > 1 ); 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 1
	setg	cl
	call	@_RTC_Check_4_to_1@4

; 81   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?AddRef@CStringData@ATL@@QAEXXZ			; ATL::CStringData::AddRef
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT
_pNewStringMgr$ = -20					; size = 4
_pNewData$ = -8						; size = 4
_pData$ = 8						; size = 4
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CloneData, COMDAT

; 801  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 802  : 		CStringData* pNewData = NULL;

	mov	DWORD PTR _pNewData$[ebp], 0

; 803  : 
; 804  : 		IAtlStringMgr* pNewStringMgr = pData->pStringMgr->Clone();

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewStringMgr$[ebp], eax

; 805  : 		if( !pData->IsLocked() && (pNewStringMgr == pData->pStringMgr) )

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?IsLocked@CStringData@ATL@@QBE_NXZ	; ATL::CStringData::IsLocked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L92891
	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR _pNewStringMgr$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $L92891

; 806  : 		{
; 807  : 			pNewData = pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pNewData$[ebp], eax

; 808  : 			pNewData->AddRef();

	mov	ecx, DWORD PTR _pNewData$[ebp]
	call	?AddRef@CStringData@ATL@@QAEXXZ		; ATL::CStringData::AddRef

; 809  : 		}
; 810  : 		else

	jmp	SHORT $L92892
$L92891:

; 811  : 		{
; 812  : 			pNewData = pNewStringMgr->Allocate( pData->nDataLength, sizeof( XCHAR ) );

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pNewStringMgr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pNewStringMgr$[ebp]
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$[ebp], eax

; 813  : 			if( pNewData == NULL )

	cmp	DWORD PTR _pNewData$[ebp], 0
	jne	SHORT $L92894

; 814  : 			{
; 815  : 				ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L92894:

; 816  : 			}
; 817  : 			pNewData->nDataLength = pData->nDataLength;

	mov	eax, DWORD PTR _pNewData$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 818  : 			CopyChars( PXSTR( pNewData->data() ), PCXSTR( pData->data() ), pData->nDataLength+1 );  // Copy '\0'

	mov	eax, DWORD PTR _pData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _pData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	mov	ecx, DWORD PTR _pNewData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	call	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
	add	esp, 12					; 0000000cH
$L92892:

; 819  : 		}
; 820  : 
; 821  : 		return( pNewData );

	mov	eax, DWORD PTR _pNewData$[ebp]
$L94075:

; 822  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z ENDP ; ATL::CSimpleStringT<char,0>::CloneData
_TEXT	ENDS
PUBLIC	??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@		; `string'
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@ DB 'nRefs > 0', 00H ; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?AddRef@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::AddRef, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		ATLASSERT(nRefs > 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jg	SHORT $L94078
	push	OFFSET FLAT:??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
	push	0
	push	71					; 00000047H
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94078
	int	3
$L94078:

; 72   : 		_InterlockedIncrement(&nRefs);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx

; 73   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AddRef@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::AddRef
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 652  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 704  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 705  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L94082:

; 706  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
tv82 = -256						; size = 4
tv74 = -256						; size = 4
_nCharsToCopy$ = -56					; size = 4
_pNewData$ = -44					; size = 4
_nOldLength$ = -32					; size = 4
_pOldData$ = -20					; size = 4
_this$ = -8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 716  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 717  : 		int nOldLength = pOldData->nDataLength;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldLength$[ebp], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pOldData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv74[ebp], eax
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv74[ebp]
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$[ebp], eax

; 719  : 		if( pNewData == NULL )

	cmp	DWORD PTR _pNewData$[ebp], 0
	jne	SHORT $L92916

; 720  : 		{
; 721  : 			ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L92916:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

	mov	eax, DWORD PTR _nOldLength$[ebp]
	cmp	eax, DWORD PTR _nLength$[ebp]
	jge	SHORT $L94085
	mov	ecx, DWORD PTR _nOldLength$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $L94086
$L94085:
	mov	edx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$L94086:
	mov	eax, DWORD PTR tv82[ebp]
	add	eax, 1
	mov	DWORD PTR _nCharsToCopy$[ebp], eax

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

	mov	eax, DWORD PTR _nCharsToCopy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	mov	ecx, DWORD PTR _pNewData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	call	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
	add	esp, 12					; 0000000cH

; 725  : 		pNewData->nDataLength = nOldLength;

	mov	eax, DWORD PTR _pNewData$[ebp]
	mov	ecx, DWORD PTR _nOldLength$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 726  : 		pOldData->Release();

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 727  : 		Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L94084:

; 728  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@ ; `string'
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT
??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@ DB 'pOldDat'
	DB	'a->nAllocLength < nLength', 00H		; `string'
; Function compile flags: /Odt /RTCcsu /ZI
CONST	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_pNewData$ = -44					; size = 4
_pStringMgr$ = -32					; size = 4
_pOldData$ = -20					; size = 4
_this$ = -8						; size = 4
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jl	SHORT $L94089
	push	OFFSET FLAT:??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
	push	0
	push	778					; 0000030aH
	push	OFFSET FLAT:??_C@_0FD@JDCNPMMG@c?3?2program?5files?2microsoft?5visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L94089
	int	3
$L94089:

; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pStringMgr$[ebp], ecx

; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOldData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStringMgr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$[ebp], eax

; 781  : 		if( pNewData == NULL )

	cmp	DWORD PTR _pNewData$[ebp], 0
	jne	SHORT $L92926

; 782  : 		{
; 783  : 			ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L92926:

; 784  : 		}
; 785  : 		Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L94088:

; 786  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszBuffer$92935 = -44					; size = 4
_nOffset$92934 = -32					; size = 4
_nOldLength$92933 = -20					; size = 4
_this$ = -8						; size = 4
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 584  : 		if( nLength == 0 )

	cmp	DWORD PTR _nLength$[ebp], 0
	jne	SHORT $L92929

; 585  : 		{
; 586  : 			Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty

; 587  : 		}
; 588  : 		else

	jmp	SHORT $L94091
$L92929:

; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

	cmp	DWORD PTR _pszSrc$[ebp], 0
	jne	SHORT $L92931

; 597  : 				AtlThrow(E_INVALIDARG);			

	push	-2147024809				; 80070057H
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L92931:

; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
	mov	DWORD PTR _nOldLength$92933[ebp], eax

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _nOffset$92934[ebp], ecx

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
	mov	DWORD PTR _pszBuffer$92935[ebp], eax

; 605  : 			if( nOffset <= nOldLength )

	mov	eax, DWORD PTR _nOffset$92934[ebp]
	cmp	eax, DWORD PTR _nOldLength$92933[ebp]
	ja	SHORT $L92936

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$92935[ebp]
	add	ecx, DWORD PTR _nOffset$92934[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$92935[ebp]
	push	edx
	call	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
	add	esp, 12					; 0000000cH

; 608  : 			}
; 609  : 			else

	jmp	SHORT $L92937
$L92936:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$92935[ebp]
	push	edx
	call	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
	add	esp, 12					; 0000000cH
$L92937:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
$L94091:

; 614  : 		}
; 615  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
_pNewData$92811 = -44					; size = 4
_pStringMgr$ = -32					; size = 4
_pOldData$ = -20					; size = 4
_this$ = -8						; size = 4
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pStringMgr$[ebp], ecx

; 424  : 		if( pOldData->nDataLength == 0 )

	mov	eax, DWORD PTR _pOldData$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L92808

; 425  : 		{
; 426  : 			return;

	jmp	SHORT $L92805
$L92808:

; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?IsLocked@CStringData@ATL@@QBE_NXZ	; ATL::CStringData::IsLocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $L92809

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 433  : 		}
; 434  : 		else

	jmp	SHORT $L92805
$L92809:

; 435  : 		{
; 436  : 			pOldData->Release();

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

	mov	eax, DWORD PTR _pStringMgr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	call	DWORD PTR [edx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$92811[ebp], eax

; 438  : 			Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$92811[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L92805:

; 439  : 		}
; 440  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Odt /RTCcsu /ZI
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 509  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 510  : 		return( m_pszData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 511  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCcsu /ZI
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 656  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDest$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 658  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
END
